<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Namespace GLib.Internal
 </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Namespace GLib.Internal
 ">
    
      <link rel="shortcut icon" href="../favicon.ico">
      <link rel="stylesheet" href="../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../styles/docfx.css">
      <link rel="stylesheet" href="../styles/main.css">
      <meta property="docfx:navrel" content="../toc.html">
      <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../img/gircore-logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="GLib.Internal">

  <h1 id="GLib_Internal" data-uid="GLib.Internal" class="text-break">Namespace GLib.Internal
</h1>
  <div class="markdown level0 summary"></div>
  <div class="markdown level0 conceptual"></div>
  <div class="markdown level0 remarks"></div>
    <h3 id="classes">
Classes
</h3>
      <h4><a class="xref" href="GLib.Internal.Array.html">Array</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ArrayHandle.html">ArrayHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ArrayManagedHandle.html">ArrayManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ArrayNullHandle.html">ArrayNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ArrayOwnedHandle.html">ArrayOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ArrayUnownedHandle.html">ArrayUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.AsyncQueue.html">AsyncQueue</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.AsyncQueueHandle.html">AsyncQueueHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.AsyncQueueManagedHandle.html">AsyncQueueManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.AsyncQueueNullHandle.html">AsyncQueueNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.AsyncQueueOwnedHandle.html">AsyncQueueOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.AsyncQueueUnownedHandle.html">AsyncQueueUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BookmarkFile.html">BookmarkFile</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BookmarkFileHandle.html">BookmarkFileHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BookmarkFileManagedHandle.html">BookmarkFileManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BookmarkFileNullHandle.html">BookmarkFileNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BookmarkFileOwnedHandle.html">BookmarkFileOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BookmarkFileUnownedHandle.html">BookmarkFileUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ByteArray.html">ByteArray</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ByteArrayHandle.html">ByteArrayHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ByteArrayManagedHandle.html">ByteArrayManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ByteArrayNullHandle.html">ByteArrayNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ByteArrayOwnedHandle.html">ByteArrayOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ByteArrayUnownedHandle.html">ByteArrayUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Bytes.html">Bytes</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BytesHandle.html">BytesHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BytesManagedHandle.html">BytesManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BytesNullHandle.html">BytesNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BytesOwnedHandle.html">BytesOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BytesUnownedHandle.html">BytesUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Checksum.html">Checksum</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ChecksumHandle.html">ChecksumHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ChecksumManagedHandle.html">ChecksumManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ChecksumNullHandle.html">ChecksumNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ChecksumOwnedHandle.html">ChecksumOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ChecksumUnownedHandle.html">ChecksumUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ChildWatchFuncAsyncHandler.html">ChildWatchFuncAsyncHandler</a></h4>
      <section><p>Async Handler for ChildWatchFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ChildWatchFuncCallHandler.html">ChildWatchFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ChildWatchFuncForeverHandler.html">ChildWatchFuncForeverHandler</a></h4>
      <section><p>Forever Handler for ChildWatchFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ChildWatchFuncNotifiedHandler.html">ChildWatchFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for ChildWatchFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ClearHandleFuncAsyncHandler.html">ClearHandleFuncAsyncHandler</a></h4>
      <section><p>Async Handler for ClearHandleFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ClearHandleFuncCallHandler.html">ClearHandleFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ClearHandleFuncForeverHandler.html">ClearHandleFuncForeverHandler</a></h4>
      <section><p>Forever Handler for ClearHandleFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ClearHandleFuncNotifiedHandler.html">ClearHandleFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for ClearHandleFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.CompareDataFuncAsyncHandler.html">CompareDataFuncAsyncHandler</a></h4>
      <section><p>Async Handler for CompareDataFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.CompareDataFuncCallHandler.html">CompareDataFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CompareDataFuncForeverHandler.html">CompareDataFuncForeverHandler</a></h4>
      <section><p>Forever Handler for CompareDataFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.CompareDataFuncNotifiedHandler.html">CompareDataFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for CompareDataFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.CompareFuncAsyncHandler.html">CompareFuncAsyncHandler</a></h4>
      <section><p>Async Handler for CompareFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.CompareFuncCallHandler.html">CompareFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CompareFuncForeverHandler.html">CompareFuncForeverHandler</a></h4>
      <section><p>Forever Handler for CompareFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.CompareFuncNotifiedHandler.html">CompareFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for CompareFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.Cond.html">Cond</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CondHandle.html">CondHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CondManagedHandle.html">CondManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CondNullHandle.html">CondNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CondOwnedHandle.html">CondOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CondUnownedHandle.html">CondUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CopyFuncAsyncHandler.html">CopyFuncAsyncHandler</a></h4>
      <section><p>Async Handler for CopyFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.CopyFuncCallHandler.html">CopyFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CopyFuncForeverHandler.html">CopyFuncForeverHandler</a></h4>
      <section><p>Forever Handler for CopyFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.CopyFuncNotifiedHandler.html">CopyFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for CopyFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.DataForeachFuncAsyncHandler.html">DataForeachFuncAsyncHandler</a></h4>
      <section><p>Async Handler for DataForeachFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.DataForeachFuncCallHandler.html">DataForeachFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DataForeachFuncForeverHandler.html">DataForeachFuncForeverHandler</a></h4>
      <section><p>Forever Handler for DataForeachFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.DataForeachFuncNotifiedHandler.html">DataForeachFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for DataForeachFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.DataHandle.html">DataHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DataManagedHandle.html">DataManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DataNullHandle.html">DataNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DataOwnedHandle.html">DataOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DataUnownedHandle.html">DataUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Date.html">Date</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateHandle.html">DateHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateManagedHandle.html">DateManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateNullHandle.html">DateNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateOwnedHandle.html">DateOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateTime.html">DateTime</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateTimeHandle.html">DateTimeHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateTimeManagedHandle.html">DateTimeManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateTimeNullHandle.html">DateTimeNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateTimeOwnedHandle.html">DateTimeOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateTimeUnownedHandle.html">DateTimeUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateUnownedHandle.html">DateUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DebugKeyHandle.html">DebugKeyHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DebugKeyManagedHandle.html">DebugKeyManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DebugKeyNullHandle.html">DebugKeyNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DebugKeyOwnedHandle.html">DebugKeyOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DebugKeyUnownedHandle.html">DebugKeyUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DestroyNotifyAsyncHandler.html">DestroyNotifyAsyncHandler</a></h4>
      <section><p>Async Handler for DestroyNotify. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.DestroyNotifyCallHandler.html">DestroyNotifyCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DestroyNotifyForeverHandler.html">DestroyNotifyForeverHandler</a></h4>
      <section><p>Forever Handler for DestroyNotify. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.DestroyNotifyNotifiedHandler.html">DestroyNotifyNotifiedHandler</a></h4>
      <section><p>Notified Handler for DestroyNotify. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.Dir.html">Dir</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DirHandle.html">DirHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DirManagedHandle.html">DirManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DirNullHandle.html">DirNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DirOwnedHandle.html">DirOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DirUnownedHandle.html">DirUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DuplicateFuncAsyncHandler.html">DuplicateFuncAsyncHandler</a></h4>
      <section><p>Async Handler for DuplicateFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.DuplicateFuncCallHandler.html">DuplicateFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DuplicateFuncForeverHandler.html">DuplicateFuncForeverHandler</a></h4>
      <section><p>Forever Handler for DuplicateFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.DuplicateFuncNotifiedHandler.html">DuplicateFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for DuplicateFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.EqualFuncAsyncHandler.html">EqualFuncAsyncHandler</a></h4>
      <section><p>Async Handler for EqualFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.EqualFuncCallHandler.html">EqualFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.EqualFuncForeverHandler.html">EqualFuncForeverHandler</a></h4>
      <section><p>Forever Handler for EqualFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.EqualFuncFullAsyncHandler.html">EqualFuncFullAsyncHandler</a></h4>
      <section><p>Async Handler for EqualFuncFull. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.EqualFuncFullCallHandler.html">EqualFuncFullCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.EqualFuncFullForeverHandler.html">EqualFuncFullForeverHandler</a></h4>
      <section><p>Forever Handler for EqualFuncFull. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.EqualFuncFullNotifiedHandler.html">EqualFuncFullNotifiedHandler</a></h4>
      <section><p>Notified Handler for EqualFuncFull. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.EqualFuncNotifiedHandler.html">EqualFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for EqualFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.Error.html">Error</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ErrorClearFuncAsyncHandler.html">ErrorClearFuncAsyncHandler</a></h4>
      <section><p>Async Handler for ErrorClearFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ErrorClearFuncCallHandler.html">ErrorClearFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ErrorClearFuncForeverHandler.html">ErrorClearFuncForeverHandler</a></h4>
      <section><p>Forever Handler for ErrorClearFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ErrorClearFuncNotifiedHandler.html">ErrorClearFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for ErrorClearFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ErrorCopyFuncAsyncHandler.html">ErrorCopyFuncAsyncHandler</a></h4>
      <section><p>Async Handler for ErrorCopyFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ErrorCopyFuncCallHandler.html">ErrorCopyFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ErrorCopyFuncForeverHandler.html">ErrorCopyFuncForeverHandler</a></h4>
      <section><p>Forever Handler for ErrorCopyFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ErrorCopyFuncNotifiedHandler.html">ErrorCopyFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for ErrorCopyFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ErrorHandle.html">ErrorHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ErrorInitFuncAsyncHandler.html">ErrorInitFuncAsyncHandler</a></h4>
      <section><p>Async Handler for ErrorInitFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ErrorInitFuncCallHandler.html">ErrorInitFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ErrorInitFuncForeverHandler.html">ErrorInitFuncForeverHandler</a></h4>
      <section><p>Forever Handler for ErrorInitFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ErrorInitFuncNotifiedHandler.html">ErrorInitFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for ErrorInitFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ErrorManagedHandle.html">ErrorManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ErrorNullHandle.html">ErrorNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ErrorOwnedHandle.html">ErrorOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ErrorUnownedHandle.html">ErrorUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.FreeFuncAsyncHandler.html">FreeFuncAsyncHandler</a></h4>
      <section><p>Async Handler for FreeFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.FreeFuncCallHandler.html">FreeFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.FreeFuncForeverHandler.html">FreeFuncForeverHandler</a></h4>
      <section><p>Forever Handler for FreeFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.FreeFuncNotifiedHandler.html">FreeFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for FreeFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.FuncAsyncHandler.html">FuncAsyncHandler</a></h4>
      <section><p>Async Handler for Func. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.FuncCallHandler.html">FuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.FuncForeverHandler.html">FuncForeverHandler</a></h4>
      <section><p>Forever Handler for Func. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.FuncNotifiedHandler.html">FuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for Func. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.Functions.html">Functions</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HFuncAsyncHandler.html">HFuncAsyncHandler</a></h4>
      <section><p>Async Handler for HFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HFuncCallHandler.html">HFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HFuncForeverHandler.html">HFuncForeverHandler</a></h4>
      <section><p>Forever Handler for HFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HFuncNotifiedHandler.html">HFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for HFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HRFuncAsyncHandler.html">HRFuncAsyncHandler</a></h4>
      <section><p>Async Handler for HRFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HRFuncCallHandler.html">HRFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HRFuncForeverHandler.html">HRFuncForeverHandler</a></h4>
      <section><p>Forever Handler for HRFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HRFuncNotifiedHandler.html">HRFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for HRFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HashFuncAsyncHandler.html">HashFuncAsyncHandler</a></h4>
      <section><p>Async Handler for HashFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HashFuncCallHandler.html">HashFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashFuncForeverHandler.html">HashFuncForeverHandler</a></h4>
      <section><p>Forever Handler for HashFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HashFuncNotifiedHandler.html">HashFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for HashFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HashTable.html">HashTable</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableHandle.html">HashTableHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableIter.html">HashTableIter</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableIterHandle.html">HashTableIterHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableIterManagedHandle.html">HashTableIterManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableIterNullHandle.html">HashTableIterNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableIterOwnedHandle.html">HashTableIterOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableIterUnownedHandle.html">HashTableIterUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableManagedHandle.html">HashTableManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableNullHandle.html">HashTableNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableOwnedHandle.html">HashTableOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableUnownedHandle.html">HashTableUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Hmac.html">Hmac</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HmacHandle.html">HmacHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HmacManagedHandle.html">HmacManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HmacNullHandle.html">HmacNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HmacOwnedHandle.html">HmacOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HmacUnownedHandle.html">HmacUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Hook.html">Hook</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookCheckFuncAsyncHandler.html">HookCheckFuncAsyncHandler</a></h4>
      <section><p>Async Handler for HookCheckFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookCheckFuncCallHandler.html">HookCheckFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookCheckFuncForeverHandler.html">HookCheckFuncForeverHandler</a></h4>
      <section><p>Forever Handler for HookCheckFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookCheckFuncNotifiedHandler.html">HookCheckFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for HookCheckFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookCheckMarshallerAsyncHandler.html">HookCheckMarshallerAsyncHandler</a></h4>
      <section><p>Async Handler for HookCheckMarshaller. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookCheckMarshallerCallHandler.html">HookCheckMarshallerCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookCheckMarshallerForeverHandler.html">HookCheckMarshallerForeverHandler</a></h4>
      <section><p>Forever Handler for HookCheckMarshaller. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookCheckMarshallerNotifiedHandler.html">HookCheckMarshallerNotifiedHandler</a></h4>
      <section><p>Notified Handler for HookCheckMarshaller. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookCompareFuncAsyncHandler.html">HookCompareFuncAsyncHandler</a></h4>
      <section><p>Async Handler for HookCompareFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookCompareFuncCallHandler.html">HookCompareFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookCompareFuncForeverHandler.html">HookCompareFuncForeverHandler</a></h4>
      <section><p>Forever Handler for HookCompareFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookCompareFuncNotifiedHandler.html">HookCompareFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for HookCompareFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookFinalizeFuncAsyncHandler.html">HookFinalizeFuncAsyncHandler</a></h4>
      <section><p>Async Handler for HookFinalizeFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookFinalizeFuncCallHandler.html">HookFinalizeFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookFinalizeFuncForeverHandler.html">HookFinalizeFuncForeverHandler</a></h4>
      <section><p>Forever Handler for HookFinalizeFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookFinalizeFuncNotifiedHandler.html">HookFinalizeFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for HookFinalizeFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookFindFuncAsyncHandler.html">HookFindFuncAsyncHandler</a></h4>
      <section><p>Async Handler for HookFindFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookFindFuncCallHandler.html">HookFindFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookFindFuncForeverHandler.html">HookFindFuncForeverHandler</a></h4>
      <section><p>Forever Handler for HookFindFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookFindFuncNotifiedHandler.html">HookFindFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for HookFindFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookFuncAsyncHandler.html">HookFuncAsyncHandler</a></h4>
      <section><p>Async Handler for HookFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookFuncCallHandler.html">HookFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookFuncForeverHandler.html">HookFuncForeverHandler</a></h4>
      <section><p>Forever Handler for HookFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookFuncNotifiedHandler.html">HookFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for HookFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookHandle.html">HookHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookList.html">HookList</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookListHandle.html">HookListHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookListManagedHandle.html">HookListManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookListNullHandle.html">HookListNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookListOwnedHandle.html">HookListOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookListUnownedHandle.html">HookListUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookManagedHandle.html">HookManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookMarshallerAsyncHandler.html">HookMarshallerAsyncHandler</a></h4>
      <section><p>Async Handler for HookMarshaller. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookMarshallerCallHandler.html">HookMarshallerCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookMarshallerForeverHandler.html">HookMarshallerForeverHandler</a></h4>
      <section><p>Forever Handler for HookMarshaller. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookMarshallerNotifiedHandler.html">HookMarshallerNotifiedHandler</a></h4>
      <section><p>Notified Handler for HookMarshaller. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.HookNullHandle.html">HookNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookOwnedHandle.html">HookOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookUnownedHandle.html">HookUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IConv.html">IConv</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IConvHandle.html">IConvHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IConvManagedHandle.html">IConvManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IConvNullHandle.html">IConvNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IConvOwnedHandle.html">IConvOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IConvUnownedHandle.html">IConvUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOChannel.html">IOChannel</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOChannelHandle.html">IOChannelHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOChannelManagedHandle.html">IOChannelManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOChannelNullHandle.html">IOChannelNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOChannelOwnedHandle.html">IOChannelOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOChannelUnownedHandle.html">IOChannelUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncAsyncHandler.html">IOFuncAsyncHandler</a></h4>
      <section><p>Async Handler for IOFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.IOFuncCallHandler.html">IOFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncForeverHandler.html">IOFuncForeverHandler</a></h4>
      <section><p>Forever Handler for IOFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.IOFuncNotifiedHandler.html">IOFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for IOFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsHandle.html">IOFuncsHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsManagedHandle.html">IOFuncsManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsNullHandle.html">IOFuncsNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsOwnedHandle.html">IOFuncsOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsUnownedHandle.html">IOFuncsUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.KeyFile.html">KeyFile</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.KeyFileHandle.html">KeyFileHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.KeyFileManagedHandle.html">KeyFileManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.KeyFileNullHandle.html">KeyFileNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.KeyFileOwnedHandle.html">KeyFileOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.KeyFileUnownedHandle.html">KeyFileUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.List.html">List</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ListHandle.html">ListHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ListManagedHandle.html">ListManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ListNullHandle.html">ListNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ListOwnedHandle.html">ListOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ListUnownedHandle.html">ListUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.LogFieldHandle.html">LogFieldHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.LogFieldManagedHandle.html">LogFieldManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.LogFieldNullHandle.html">LogFieldNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.LogFieldOwnedHandle.html">LogFieldOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.LogFieldUnownedHandle.html">LogFieldUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.LogFuncAsyncHandler.html">LogFuncAsyncHandler</a></h4>
      <section><p>Async Handler for LogFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.LogFuncCallHandler.html">LogFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.LogFuncForeverHandler.html">LogFuncForeverHandler</a></h4>
      <section><p>Forever Handler for LogFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.LogFuncNotifiedHandler.html">LogFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for LogFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.LogWriterFuncAsyncHandler.html">LogWriterFuncAsyncHandler</a></h4>
      <section><p>Async Handler for LogWriterFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.LogWriterFuncCallHandler.html">LogWriterFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.LogWriterFuncForeverHandler.html">LogWriterFuncForeverHandler</a></h4>
      <section><p>Forever Handler for LogWriterFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.LogWriterFuncNotifiedHandler.html">LogWriterFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for LogWriterFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.MainContext.html">MainContext</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainContextHandle.html">MainContextHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainContextManagedHandle.html">MainContextManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainContextNullHandle.html">MainContextNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainContextOwnedHandle.html">MainContextOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainContextUnownedHandle.html">MainContextUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainLoop.html">MainLoop</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainLoopHandle.html">MainLoopHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainLoopManagedHandle.html">MainLoopManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainLoopNullHandle.html">MainLoopNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainLoopOwnedHandle.html">MainLoopOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainLoopSynchronizationContext.html">MainLoopSynchronizationContext</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainLoopUnownedHandle.html">MainLoopUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MappedFile.html">MappedFile</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MappedFileHandle.html">MappedFileHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MappedFileManagedHandle.html">MappedFileManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MappedFileNullHandle.html">MappedFileNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MappedFileOwnedHandle.html">MappedFileOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MappedFileUnownedHandle.html">MappedFileUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParseContext.html">MarkupParseContext</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParseContextHandle.html">MarkupParseContextHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParseContextManagedHandle.html">MarkupParseContextManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParseContextNullHandle.html">MarkupParseContextNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParseContextOwnedHandle.html">MarkupParseContextOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParseContextUnownedHandle.html">MarkupParseContextUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParserHandle.html">MarkupParserHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParserManagedHandle.html">MarkupParserManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParserNullHandle.html">MarkupParserNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParserOwnedHandle.html">MarkupParserOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParserUnownedHandle.html">MarkupParserUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MatchInfo.html">MatchInfo</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MatchInfoHandle.html">MatchInfoHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MatchInfoManagedHandle.html">MatchInfoManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MatchInfoNullHandle.html">MatchInfoNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MatchInfoOwnedHandle.html">MatchInfoOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MatchInfoUnownedHandle.html">MatchInfoUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MemVTableHandle.html">MemVTableHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MemVTableManagedHandle.html">MemVTableManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MemVTableNullHandle.html">MemVTableNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MemVTableOwnedHandle.html">MemVTableOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MemVTableUnownedHandle.html">MemVTableUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Mutex.html">Mutex</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Node.html">Node</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NodeForeachFuncAsyncHandler.html">NodeForeachFuncAsyncHandler</a></h4>
      <section><p>Async Handler for NodeForeachFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.NodeForeachFuncCallHandler.html">NodeForeachFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NodeForeachFuncForeverHandler.html">NodeForeachFuncForeverHandler</a></h4>
      <section><p>Forever Handler for NodeForeachFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.NodeForeachFuncNotifiedHandler.html">NodeForeachFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for NodeForeachFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.NodeHandle.html">NodeHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NodeManagedHandle.html">NodeManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NodeNullHandle.html">NodeNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NodeOwnedHandle.html">NodeOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NodeTraverseFuncAsyncHandler.html">NodeTraverseFuncAsyncHandler</a></h4>
      <section><p>Async Handler for NodeTraverseFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.NodeTraverseFuncCallHandler.html">NodeTraverseFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NodeTraverseFuncForeverHandler.html">NodeTraverseFuncForeverHandler</a></h4>
      <section><p>Forever Handler for NodeTraverseFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.NodeTraverseFuncNotifiedHandler.html">NodeTraverseFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for NodeTraverseFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.NodeUnownedHandle.html">NodeUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NonNullablePlatformStringHandle.html">NonNullablePlatformStringHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NonNullablePlatformStringOwnedHandle.html">NonNullablePlatformStringOwnedHandle</a></h4>
      <section><p>Represents an owned non nullable platform string. If an instance of this class
is collected by the garbage collecctor the associated memory is freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.NonNullablePlatformStringUnownedHandle.html">NonNullablePlatformStringUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NonNullableUtf8StringHandle.html">NonNullableUtf8StringHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NonNullableUtf8StringOwnedHandle.html">NonNullableUtf8StringOwnedHandle</a></h4>
      <section><p>Represents an owned non nullable utf8 string. If an instance of this class
is collected by the garbage collecctor the associated memory is freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.NonNullableUtf8StringUnownedHandle.html">NonNullableUtf8StringUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NullHandleException.html">NullHandleException</a></h4>
      <section><p>This exception is raised if an unexpeected NULL handle is received. Please report any occurence of this
exception to the gir.core project as it is likely to be a generation error.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.NullablePlatformStringHandle.html">NullablePlatformStringHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NullablePlatformStringOwnedHandle.html">NullablePlatformStringOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NullablePlatformStringUnownedHandle.html">NullablePlatformStringUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NullableUtf8StringHandle.html">NullableUtf8StringHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NullableUtf8StringOwnedHandle.html">NullableUtf8StringOwnedHandle</a></h4>
      <section><p>Represents an owned nullable utf8 string. If an instance of this class
is collected by the garbage collecctor the associated memory is freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.NullableUtf8StringUnownedHandle.html">NullableUtf8StringUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Once.html">Once</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OnceHandle.html">OnceHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OnceManagedHandle.html">OnceManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OnceNullHandle.html">OnceNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OnceOwnedHandle.html">OnceOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OnceUnownedHandle.html">OnceUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionArgFuncAsyncHandler.html">OptionArgFuncAsyncHandler</a></h4>
      <section><p>Async Handler for OptionArgFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.OptionArgFuncCallHandler.html">OptionArgFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionArgFuncForeverHandler.html">OptionArgFuncForeverHandler</a></h4>
      <section><p>Forever Handler for OptionArgFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.OptionArgFuncNotifiedHandler.html">OptionArgFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for OptionArgFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.OptionContext.html">OptionContext</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionContextHandle.html">OptionContextHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionContextManagedHandle.html">OptionContextManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionContextNullHandle.html">OptionContextNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionContextOwnedHandle.html">OptionContextOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionContextUnownedHandle.html">OptionContextUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionEntryHandle.html">OptionEntryHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionEntryManagedHandle.html">OptionEntryManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionEntryNullHandle.html">OptionEntryNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionEntryOwnedHandle.html">OptionEntryOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionEntryUnownedHandle.html">OptionEntryUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionErrorFuncAsyncHandler.html">OptionErrorFuncAsyncHandler</a></h4>
      <section><p>Async Handler for OptionErrorFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.OptionErrorFuncCallHandler.html">OptionErrorFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionErrorFuncForeverHandler.html">OptionErrorFuncForeverHandler</a></h4>
      <section><p>Forever Handler for OptionErrorFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.OptionErrorFuncNotifiedHandler.html">OptionErrorFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for OptionErrorFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.OptionGroup.html">OptionGroup</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionGroupHandle.html">OptionGroupHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionGroupManagedHandle.html">OptionGroupManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionGroupNullHandle.html">OptionGroupNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionGroupOwnedHandle.html">OptionGroupOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionGroupUnownedHandle.html">OptionGroupUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionParseFuncAsyncHandler.html">OptionParseFuncAsyncHandler</a></h4>
      <section><p>Async Handler for OptionParseFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.OptionParseFuncCallHandler.html">OptionParseFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionParseFuncForeverHandler.html">OptionParseFuncForeverHandler</a></h4>
      <section><p>Forever Handler for OptionParseFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.OptionParseFuncNotifiedHandler.html">OptionParseFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for OptionParseFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.PathBuf.html">PathBuf</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PathBufHandle.html">PathBufHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PathBufManagedHandle.html">PathBufManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PathBufNullHandle.html">PathBufNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PathBufOwnedHandle.html">PathBufOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PathBufUnownedHandle.html">PathBufUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PatternSpec.html">PatternSpec</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PatternSpecHandle.html">PatternSpecHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PatternSpecManagedHandle.html">PatternSpecManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PatternSpecNullHandle.html">PatternSpecNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PatternSpecOwnedHandle.html">PatternSpecOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PatternSpecUnownedHandle.html">PatternSpecUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PollFD.html">PollFD</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PollFDHandle.html">PollFDHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PollFDManagedHandle.html">PollFDManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PollFDNullHandle.html">PollFDNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PollFDOwnedHandle.html">PollFDOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PollFDUnownedHandle.html">PollFDUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PollFuncAsyncHandler.html">PollFuncAsyncHandler</a></h4>
      <section><p>Async Handler for PollFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.PollFuncCallHandler.html">PollFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PollFuncForeverHandler.html">PollFuncForeverHandler</a></h4>
      <section><p>Forever Handler for PollFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.PollFuncNotifiedHandler.html">PollFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for PollFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.PrintFuncAsyncHandler.html">PrintFuncAsyncHandler</a></h4>
      <section><p>Async Handler for PrintFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.PrintFuncCallHandler.html">PrintFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PrintFuncForeverHandler.html">PrintFuncForeverHandler</a></h4>
      <section><p>Forever Handler for PrintFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.PrintFuncNotifiedHandler.html">PrintFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for PrintFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.Private.html">Private</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PrivateHandle.html">PrivateHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PrivateManagedHandle.html">PrivateManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PrivateNullHandle.html">PrivateNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PrivateOwnedHandle.html">PrivateOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PrivateUnownedHandle.html">PrivateUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PtrArray.html">PtrArray</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PtrArrayHandle.html">PtrArrayHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PtrArrayManagedHandle.html">PtrArrayManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PtrArrayNullHandle.html">PtrArrayNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PtrArrayOwnedHandle.html">PtrArrayOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PtrArrayUnownedHandle.html">PtrArrayUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Queue.html">Queue</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.QueueHandle.html">QueueHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.QueueManagedHandle.html">QueueManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.QueueNullHandle.html">QueueNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.QueueOwnedHandle.html">QueueOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.QueueUnownedHandle.html">QueueUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RWLock.html">RWLock</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RWLockHandle.html">RWLockHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RWLockManagedHandle.html">RWLockManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RWLockNullHandle.html">RWLockNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RWLockOwnedHandle.html">RWLockOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RWLockUnownedHandle.html">RWLockUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Rand.html">Rand</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RandHandle.html">RandHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RandManagedHandle.html">RandManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RandNullHandle.html">RandNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RandOwnedHandle.html">RandOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RandUnownedHandle.html">RandUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RecMutex.html">RecMutex</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RecMutexHandle.html">RecMutexHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RecMutexManagedHandle.html">RecMutexManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RecMutexNullHandle.html">RecMutexNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RecMutexOwnedHandle.html">RecMutexOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RecMutexUnownedHandle.html">RecMutexUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Regex.html">Regex</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RegexEvalCallbackAsyncHandler.html">RegexEvalCallbackAsyncHandler</a></h4>
      <section><p>Async Handler for RegexEvalCallback. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.RegexEvalCallbackCallHandler.html">RegexEvalCallbackCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RegexEvalCallbackForeverHandler.html">RegexEvalCallbackForeverHandler</a></h4>
      <section><p>Forever Handler for RegexEvalCallback. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.RegexEvalCallbackNotifiedHandler.html">RegexEvalCallbackNotifiedHandler</a></h4>
      <section><p>Notified Handler for RegexEvalCallback. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.RegexHandle.html">RegexHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RegexManagedHandle.html">RegexManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RegexNullHandle.html">RegexNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RegexOwnedHandle.html">RegexOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RegexUnownedHandle.html">RegexUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SList.html">SList</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SListHandle.html">SListHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SListManagedHandle.html">SListManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SListNullHandle.html">SListNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SListOwnedHandle.html">SListOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SListUnownedHandle.html">SListUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Scanner.html">Scanner</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerConfigHandle.html">ScannerConfigHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerConfigManagedHandle.html">ScannerConfigManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerConfigNullHandle.html">ScannerConfigNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerConfigOwnedHandle.html">ScannerConfigOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerConfigUnownedHandle.html">ScannerConfigUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerHandle.html">ScannerHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerManagedHandle.html">ScannerManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerMsgFuncAsyncHandler.html">ScannerMsgFuncAsyncHandler</a></h4>
      <section><p>Async Handler for ScannerMsgFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ScannerMsgFuncCallHandler.html">ScannerMsgFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerMsgFuncForeverHandler.html">ScannerMsgFuncForeverHandler</a></h4>
      <section><p>Forever Handler for ScannerMsgFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ScannerMsgFuncNotifiedHandler.html">ScannerMsgFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for ScannerMsgFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ScannerNullHandle.html">ScannerNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerOwnedHandle.html">ScannerOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerUnownedHandle.html">ScannerUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Sequence.html">Sequence</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceHandle.html">SequenceHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceIter.html">SequenceIter</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceIterCompareFuncAsyncHandler.html">SequenceIterCompareFuncAsyncHandler</a></h4>
      <section><p>Async Handler for SequenceIterCompareFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SequenceIterCompareFuncCallHandler.html">SequenceIterCompareFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceIterCompareFuncForeverHandler.html">SequenceIterCompareFuncForeverHandler</a></h4>
      <section><p>Forever Handler for SequenceIterCompareFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SequenceIterCompareFuncNotifiedHandler.html">SequenceIterCompareFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for SequenceIterCompareFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SequenceIterHandle.html">SequenceIterHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceIterManagedHandle.html">SequenceIterManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceIterNullHandle.html">SequenceIterNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceIterOwnedHandle.html">SequenceIterOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceIterUnownedHandle.html">SequenceIterUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceManagedHandle.html">SequenceManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceNullHandle.html">SequenceNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceOwnedHandle.html">SequenceOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceUnownedHandle.html">SequenceUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Source.html">Source</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceCallbackFuncsHandle.html">SourceCallbackFuncsHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceCallbackFuncsManagedHandle.html">SourceCallbackFuncsManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceCallbackFuncsNullHandle.html">SourceCallbackFuncsNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceCallbackFuncsOwnedHandle.html">SourceCallbackFuncsOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceCallbackFuncsUnownedHandle.html">SourceCallbackFuncsUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceDisposeFuncAsyncHandler.html">SourceDisposeFuncAsyncHandler</a></h4>
      <section><p>Async Handler for SourceDisposeFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SourceDisposeFuncCallHandler.html">SourceDisposeFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceDisposeFuncForeverHandler.html">SourceDisposeFuncForeverHandler</a></h4>
      <section><p>Forever Handler for SourceDisposeFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SourceDisposeFuncNotifiedHandler.html">SourceDisposeFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for SourceDisposeFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SourceDummyMarshalAsyncHandler.html">SourceDummyMarshalAsyncHandler</a></h4>
      <section><p>Async Handler for SourceDummyMarshal. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SourceDummyMarshalCallHandler.html">SourceDummyMarshalCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceDummyMarshalForeverHandler.html">SourceDummyMarshalForeverHandler</a></h4>
      <section><p>Forever Handler for SourceDummyMarshal. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SourceDummyMarshalNotifiedHandler.html">SourceDummyMarshalNotifiedHandler</a></h4>
      <section><p>Notified Handler for SourceDummyMarshal. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncAsyncHandler.html">SourceFuncAsyncHandler</a></h4>
      <section><p>Async Handler for SourceFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncCallHandler.html">SourceFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncForeverHandler.html">SourceFuncForeverHandler</a></h4>
      <section><p>Forever Handler for SourceFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncNotifiedHandler.html">SourceFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for SourceFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncsHandle.html">SourceFuncsHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncsManagedHandle.html">SourceFuncsManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncsNullHandle.html">SourceFuncsNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncsOwnedHandle.html">SourceFuncsOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncsUnownedHandle.html">SourceFuncsUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceHandle.html">SourceHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceManagedHandle.html">SourceManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceNullHandle.html">SourceNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceOnceFuncAsyncHandler.html">SourceOnceFuncAsyncHandler</a></h4>
      <section><p>Async Handler for SourceOnceFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SourceOnceFuncCallHandler.html">SourceOnceFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceOnceFuncForeverHandler.html">SourceOnceFuncForeverHandler</a></h4>
      <section><p>Forever Handler for SourceOnceFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SourceOnceFuncNotifiedHandler.html">SourceOnceFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for SourceOnceFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SourceOwnedHandle.html">SourceOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourcePrivateHandle.html">SourcePrivateHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourcePrivateManagedHandle.html">SourcePrivateManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourcePrivateNullHandle.html">SourcePrivateNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourcePrivateOwnedHandle.html">SourcePrivateOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourcePrivateUnownedHandle.html">SourcePrivateUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceUnownedHandle.html">SourceUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SpawnChildSetupFuncAsyncHandler.html">SpawnChildSetupFuncAsyncHandler</a></h4>
      <section><p>Async Handler for SpawnChildSetupFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SpawnChildSetupFuncCallHandler.html">SpawnChildSetupFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SpawnChildSetupFuncForeverHandler.html">SpawnChildSetupFuncForeverHandler</a></h4>
      <section><p>Forever Handler for SpawnChildSetupFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.SpawnChildSetupFuncNotifiedHandler.html">SpawnChildSetupFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for SpawnChildSetupFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.StatBufHandle.html">StatBufHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StatBufManagedHandle.html">StatBufManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StatBufNullHandle.html">StatBufNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StatBufOwnedHandle.html">StatBufOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StatBufUnownedHandle.html">StatBufUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.String.html">String</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringArrayNullTerminatedSafeHandle.html">StringArrayNullTerminatedSafeHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringChunk.html">StringChunk</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringChunkHandle.html">StringChunkHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringChunkManagedHandle.html">StringChunkManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringChunkNullHandle.html">StringChunkNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringChunkOwnedHandle.html">StringChunkOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringChunkUnownedHandle.html">StringChunkUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringHandle.html">StringHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringHelper.html">StringHelper</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringManagedHandle.html">StringManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringNullHandle.html">StringNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringOwnedHandle.html">StringOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringUnownedHandle.html">StringUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StrvBuilder.html">StrvBuilder</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StrvBuilderHandle.html">StrvBuilderHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StrvBuilderManagedHandle.html">StrvBuilderManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StrvBuilderNullHandle.html">StrvBuilderNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StrvBuilderOwnedHandle.html">StrvBuilderOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StrvBuilderUnownedHandle.html">StrvBuilderUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestCase.html">TestCase</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestCaseHandle.html">TestCaseHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestCaseManagedHandle.html">TestCaseManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestCaseNullHandle.html">TestCaseNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestCaseOwnedHandle.html">TestCaseOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestCaseUnownedHandle.html">TestCaseUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestConfigHandle.html">TestConfigHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestConfigManagedHandle.html">TestConfigManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestConfigNullHandle.html">TestConfigNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestConfigOwnedHandle.html">TestConfigOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestConfigUnownedHandle.html">TestConfigUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestDataFuncAsyncHandler.html">TestDataFuncAsyncHandler</a></h4>
      <section><p>Async Handler for TestDataFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TestDataFuncCallHandler.html">TestDataFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestDataFuncForeverHandler.html">TestDataFuncForeverHandler</a></h4>
      <section><p>Forever Handler for TestDataFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TestDataFuncNotifiedHandler.html">TestDataFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for TestDataFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TestFixtureFuncAsyncHandler.html">TestFixtureFuncAsyncHandler</a></h4>
      <section><p>Async Handler for TestFixtureFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TestFixtureFuncCallHandler.html">TestFixtureFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestFixtureFuncForeverHandler.html">TestFixtureFuncForeverHandler</a></h4>
      <section><p>Forever Handler for TestFixtureFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TestFixtureFuncNotifiedHandler.html">TestFixtureFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for TestFixtureFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TestFuncAsyncHandler.html">TestFuncAsyncHandler</a></h4>
      <section><p>Async Handler for TestFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TestFuncCallHandler.html">TestFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestFuncForeverHandler.html">TestFuncForeverHandler</a></h4>
      <section><p>Forever Handler for TestFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TestFuncNotifiedHandler.html">TestFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for TestFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TestLogBuffer.html">TestLogBuffer</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogBufferHandle.html">TestLogBufferHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogBufferManagedHandle.html">TestLogBufferManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogBufferNullHandle.html">TestLogBufferNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogBufferOwnedHandle.html">TestLogBufferOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogBufferUnownedHandle.html">TestLogBufferUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogFatalFuncAsyncHandler.html">TestLogFatalFuncAsyncHandler</a></h4>
      <section><p>Async Handler for TestLogFatalFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TestLogFatalFuncCallHandler.html">TestLogFatalFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogFatalFuncForeverHandler.html">TestLogFatalFuncForeverHandler</a></h4>
      <section><p>Forever Handler for TestLogFatalFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TestLogFatalFuncNotifiedHandler.html">TestLogFatalFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for TestLogFatalFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TestLogMsg.html">TestLogMsg</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogMsgHandle.html">TestLogMsgHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogMsgManagedHandle.html">TestLogMsgManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogMsgNullHandle.html">TestLogMsgNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogMsgOwnedHandle.html">TestLogMsgOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogMsgUnownedHandle.html">TestLogMsgUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestSuite.html">TestSuite</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestSuiteHandle.html">TestSuiteHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestSuiteManagedHandle.html">TestSuiteManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestSuiteNullHandle.html">TestSuiteNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestSuiteOwnedHandle.html">TestSuiteOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestSuiteUnownedHandle.html">TestSuiteUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Thread.html">Thread</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadFuncAsyncHandler.html">ThreadFuncAsyncHandler</a></h4>
      <section><p>Async Handler for ThreadFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ThreadFuncCallHandler.html">ThreadFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadFuncForeverHandler.html">ThreadFuncForeverHandler</a></h4>
      <section><p>Forever Handler for ThreadFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ThreadFuncNotifiedHandler.html">ThreadFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for ThreadFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.ThreadHandle.html">ThreadHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadManagedHandle.html">ThreadManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadNullHandle.html">ThreadNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadOwnedHandle.html">ThreadOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadPool.html">ThreadPool</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadPoolHandle.html">ThreadPoolHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadPoolManagedHandle.html">ThreadPoolManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadPoolNullHandle.html">ThreadPoolNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadPoolOwnedHandle.html">ThreadPoolOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadPoolUnownedHandle.html">ThreadPoolUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadUnownedHandle.html">ThreadUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeVal.html">TimeVal</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeValHandle.html">TimeValHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeValManagedHandle.html">TimeValManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeValNullHandle.html">TimeValNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeValOwnedHandle.html">TimeValOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeValUnownedHandle.html">TimeValUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeZone.html">TimeZone</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeZoneHandle.html">TimeZoneHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeZoneManagedHandle.html">TimeZoneManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeZoneNullHandle.html">TimeZoneNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeZoneOwnedHandle.html">TimeZoneOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeZoneUnownedHandle.html">TimeZoneUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Timer.html">Timer</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimerHandle.html">TimerHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimerManagedHandle.html">TimerManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimerNullHandle.html">TimerNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimerOwnedHandle.html">TimerOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimerUnownedHandle.html">TimerUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TrashStack.html">TrashStack</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TrashStackHandle.html">TrashStackHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TrashStackManagedHandle.html">TrashStackManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TrashStackNullHandle.html">TrashStackNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TrashStackOwnedHandle.html">TrashStackOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TrashStackUnownedHandle.html">TrashStackUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TraverseFuncAsyncHandler.html">TraverseFuncAsyncHandler</a></h4>
      <section><p>Async Handler for TraverseFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TraverseFuncCallHandler.html">TraverseFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TraverseFuncForeverHandler.html">TraverseFuncForeverHandler</a></h4>
      <section><p>Forever Handler for TraverseFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TraverseFuncNotifiedHandler.html">TraverseFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for TraverseFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TraverseNodeFuncAsyncHandler.html">TraverseNodeFuncAsyncHandler</a></h4>
      <section><p>Async Handler for TraverseNodeFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TraverseNodeFuncCallHandler.html">TraverseNodeFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TraverseNodeFuncForeverHandler.html">TraverseNodeFuncForeverHandler</a></h4>
      <section><p>Forever Handler for TraverseNodeFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.TraverseNodeFuncNotifiedHandler.html">TraverseNodeFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for TraverseNodeFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.Tree.html">Tree</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeHandle.html">TreeHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeManagedHandle.html">TreeManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeNode.html">TreeNode</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeNodeHandle.html">TreeNodeHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeNodeManagedHandle.html">TreeNodeManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeNodeNullHandle.html">TreeNodeNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeNodeOwnedHandle.html">TreeNodeOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeNodeUnownedHandle.html">TreeNodeUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeNullHandle.html">TreeNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeOwnedHandle.html">TreeOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeUnownedHandle.html">TreeUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UnixFDSourceFuncAsyncHandler.html">UnixFDSourceFuncAsyncHandler</a></h4>
      <section><p>Async Handler for UnixFDSourceFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.UnixFDSourceFuncCallHandler.html">UnixFDSourceFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UnixFDSourceFuncForeverHandler.html">UnixFDSourceFuncForeverHandler</a></h4>
      <section><p>Forever Handler for UnixFDSourceFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.UnixFDSourceFuncNotifiedHandler.html">UnixFDSourceFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for UnixFDSourceFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.Uri.html">Uri</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriHandle.html">UriHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriManagedHandle.html">UriManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriNullHandle.html">UriNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriOwnedHandle.html">UriOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriParamsIter.html">UriParamsIter</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriParamsIterHandle.html">UriParamsIterHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriParamsIterManagedHandle.html">UriParamsIterManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriParamsIterNullHandle.html">UriParamsIterNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriParamsIterOwnedHandle.html">UriParamsIterOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriParamsIterUnownedHandle.html">UriParamsIterUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriUnownedHandle.html">UriUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Variant.html">Variant</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantBuilder.html">VariantBuilder</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantBuilderHandle.html">VariantBuilderHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantBuilderManagedHandle.html">VariantBuilderManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantBuilderNullHandle.html">VariantBuilderNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantBuilderOwnedHandle.html">VariantBuilderOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantBuilderUnownedHandle.html">VariantBuilderUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantDict.html">VariantDict</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantDictHandle.html">VariantDictHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantDictManagedHandle.html">VariantDictManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantDictNullHandle.html">VariantDictNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantDictOwnedHandle.html">VariantDictOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantDictUnownedHandle.html">VariantDictUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantHandle.html">VariantHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantIter.html">VariantIter</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantIterHandle.html">VariantIterHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantIterManagedHandle.html">VariantIterManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantIterNullHandle.html">VariantIterNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantIterOwnedHandle.html">VariantIterOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantIterUnownedHandle.html">VariantIterUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantManagedHandle.html">VariantManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantNullHandle.html">VariantNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantOwnedHandle.html">VariantOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantType.html">VariantType</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantTypeHandle.html">VariantTypeHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantTypeManagedHandle.html">VariantTypeManagedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantTypeNullHandle.html">VariantTypeNullHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantTypeOwnedHandle.html">VariantTypeOwnedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantTypeUnownedHandle.html">VariantTypeUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantUnownedHandle.html">VariantUnownedHandle</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VoidFuncAsyncHandler.html">VoidFuncAsyncHandler</a></h4>
      <section><p>Async Handler for VoidFunc. An async annotation indicates the closure will
be called precisely once, after which it is then available for garbage collection.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.VoidFuncCallHandler.html">VoidFuncCallHandler</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VoidFuncForeverHandler.html">VoidFuncForeverHandler</a></h4>
      <section><p>Forever Handler for VoidFunc. An forever annotation indicates the closure will
be valid until the process terminates. Therefor the object will never be freed.</p>
</section>
      <h4><a class="xref" href="GLib.Internal.VoidFuncNotifiedHandler.html">VoidFuncNotifiedHandler</a></h4>
      <section><p>Notified Handler for VoidFunc. A notified annotation indicates the closure should
be kept alive until it is manually removed by the user. This removal is indicated by a
destroy_notify event, emitted by the relevant library. Pass <code>DestroyNotify</code> in place of a
destroy_notify callback parameter.</p>
</section>
    <h3 id="structs">
Structs
</h3>
      <h4><a class="xref" href="GLib.Internal.ArrayData.html">ArrayData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.AsyncQueueData.html">AsyncQueueData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BookmarkFileData.html">BookmarkFileData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ByteArrayData.html">ByteArrayData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.BytesData.html">BytesData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ChecksumData.html">ChecksumData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CondData.html">CondData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DataData.html">DataData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateData.html">DateData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DateTimeData.html">DateTimeData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DebugKeyData.html">DebugKeyData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DirData.html">DirData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DoubleIEEE754Data.html">DoubleIEEE754Data</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ErrorData.html">ErrorData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.FloatIEEE754Data.html">FloatIEEE754Data</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableData.html">HashTableData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashTableIterData.html">HashTableIterData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HmacData.html">HmacData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookData.html">HookData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookListData.html">HookListData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IConvData.html">IConvData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOChannelData.html">IOChannelData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsData.html">IOFuncsData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.KeyFileData.html">KeyFileData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ListData.html">ListData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.LogFieldData.html">LogFieldData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainContextData.html">MainContextData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MainLoopData.html">MainLoopData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MappedFileData.html">MappedFileData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParseContextData.html">MarkupParseContextData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParserData.html">MarkupParserData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MatchInfoData.html">MatchInfoData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MemVTableData.html">MemVTableData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MutexData.html">MutexData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NodeData.html">NodeData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OnceData.html">OnceData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionContextData.html">OptionContextData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionEntryData.html">OptionEntryData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionGroupData.html">OptionGroupData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PathBufData.html">PathBufData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PatternSpecData.html">PatternSpecData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PollFDData.html">PollFDData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PrivateData.html">PrivateData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PtrArrayData.html">PtrArrayData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.QueueData.html">QueueData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RWLockData.html">RWLockData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RandData.html">RandData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RecMutexData.html">RecMutexData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RegexData.html">RegexData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SListData.html">SListData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerConfigData.html">ScannerConfigData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerData.html">ScannerData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceData.html">SequenceData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceIterData.html">SequenceIterData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceCallbackFuncsData.html">SourceCallbackFuncsData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceData.html">SourceData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncsData.html">SourceFuncsData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourcePrivateData.html">SourcePrivateData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StatBufData.html">StatBufData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringChunkData.html">StringChunkData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StringData.html">StringData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.StrvBuilderData.html">StrvBuilderData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestCaseData.html">TestCaseData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestConfigData.html">TestConfigData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogBufferData.html">TestLogBufferData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogMsgData.html">TestLogMsgData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestSuiteData.html">TestSuiteData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadData.html">ThreadData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadPoolData.html">ThreadPoolData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeValData.html">TimeValData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimeZoneData.html">TimeZoneData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TimerData.html">TimerData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TokenValueData.html">TokenValueData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TrashStackData.html">TrashStackData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeData.html">TreeData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TreeNodeData.html">TreeNodeData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriData.html">UriData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UriParamsIterData.html">UriParamsIterData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantBuilderData.html">VariantBuilderData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantData.html">VariantData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantDictData.html">VariantDictData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantIterData.html">VariantIterData</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VariantTypeData.html">VariantTypeData</a></h4>
      <section></section>
    <h3 id="delegates">
Delegates
</h3>
      <h4><a class="xref" href="GLib.Internal.ChildWatchFunc.html">ChildWatchFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ClearHandleFunc.html">ClearHandleFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CompareDataFunc.html">CompareDataFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CompareFunc.html">CompareFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.CopyFunc.html">CopyFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DataForeachFunc.html">DataForeachFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DestroyNotify.html">DestroyNotify</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.DuplicateFunc.html">DuplicateFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.EqualFunc.html">EqualFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.EqualFuncFull.html">EqualFuncFull</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ErrorClearFunc.html">ErrorClearFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ErrorCopyFunc.html">ErrorCopyFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ErrorInitFunc.html">ErrorInitFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.FreeFunc.html">FreeFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.Func.html">Func</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HFunc.html">HFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HRFunc.html">HRFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HashFunc.html">HashFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookCheckFunc.html">HookCheckFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookCheckMarshaller.html">HookCheckMarshaller</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookCompareFunc.html">HookCompareFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookFinalizeFunc.html">HookFinalizeFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookFindFunc.html">HookFindFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookFunc.html">HookFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.HookMarshaller.html">HookMarshaller</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFunc.html">IOFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsData.IoCloseCallback.html">IOFuncsData.IoCloseCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsData.IoCreateWatchCallback.html">IOFuncsData.IoCreateWatchCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsData.IoFreeCallback.html">IOFuncsData.IoFreeCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsData.IoGetFlagsCallback.html">IOFuncsData.IoGetFlagsCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsData.IoReadCallback.html">IOFuncsData.IoReadCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsData.IoSeekCallback.html">IOFuncsData.IoSeekCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsData.IoSetFlagsCallback.html">IOFuncsData.IoSetFlagsCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.IOFuncsData.IoWriteCallback.html">IOFuncsData.IoWriteCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.LogFunc.html">LogFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.LogWriterFunc.html">LogWriterFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParserData.EndElementCallback.html">MarkupParserData.EndElementCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParserData.ErrorCallback.html">MarkupParserData.ErrorCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParserData.PassthroughCallback.html">MarkupParserData.PassthroughCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParserData.StartElementCallback.html">MarkupParserData.StartElementCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MarkupParserData.TextCallback.html">MarkupParserData.TextCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MemVTableData.CallocCallback.html">MemVTableData.CallocCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MemVTableData.FreeCallback.html">MemVTableData.FreeCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MemVTableData.MallocCallback.html">MemVTableData.MallocCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MemVTableData.ReallocCallback.html">MemVTableData.ReallocCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MemVTableData.TryMallocCallback.html">MemVTableData.TryMallocCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.MemVTableData.TryReallocCallback.html">MemVTableData.TryReallocCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NodeForeachFunc.html">NodeForeachFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.NodeTraverseFunc.html">NodeTraverseFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionArgFunc.html">OptionArgFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionErrorFunc.html">OptionErrorFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.OptionParseFunc.html">OptionParseFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PollFunc.html">PollFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.PrintFunc.html">PrintFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.RegexEvalCallback.html">RegexEvalCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ScannerMsgFunc.html">ScannerMsgFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SequenceIterCompareFunc.html">SequenceIterCompareFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceCallbackFuncsData.GetCallback.html">SourceCallbackFuncsData.GetCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceCallbackFuncsData.RefCallback.html">SourceCallbackFuncsData.RefCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceCallbackFuncsData.UnrefCallback.html">SourceCallbackFuncsData.UnrefCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceDisposeFunc.html">SourceDisposeFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceDummyMarshal.html">SourceDummyMarshal</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceFunc.html">SourceFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncsData.CheckCallback.html">SourceFuncsData.CheckCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncsData.DispatchCallback.html">SourceFuncsData.DispatchCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncsData.FinalizeCallback.html">SourceFuncsData.FinalizeCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceFuncsData.PrepareCallback.html">SourceFuncsData.PrepareCallback</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SourceOnceFunc.html">SourceOnceFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.SpawnChildSetupFunc.html">SpawnChildSetupFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestDataFunc.html">TestDataFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestFixtureFunc.html">TestFixtureFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestFunc.html">TestFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TestLogFatalFunc.html">TestLogFatalFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.ThreadFunc.html">ThreadFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TranslateFunc.html">TranslateFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TraverseFunc.html">TraverseFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.TraverseNodeFunc.html">TraverseNodeFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.UnixFDSourceFunc.html">UnixFDSourceFunc</a></h4>
      <section></section>
      <h4><a class="xref" href="GLib.Internal.VoidFunc.html">VoidFunc</a></h4>
      <section></section>


</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      
      <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
