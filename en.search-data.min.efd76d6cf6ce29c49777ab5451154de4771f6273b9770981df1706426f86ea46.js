"use strict";(function(){const t={cache:!0};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/docs/apps.html",title:"Apps",section:"Docs",content:` Applications # Applications using gir.core. To add a new application to the list edit this page .
Denaro # Denaro is a personal finance manager.
`}),e.add({id:1,href:"/docs/build.html",title:"Build",section:"Docs",content:" Build # To generate the bindings locally execute the following commands in a terminal. Make sure to initialise submodules with --recursive otherwise the gir-files directory will not be loaded properly.\n$ git clone --recursive https://github.com/gircore/gir.core.git $ cd gir.core/src $ dotnet fsi GenerateLibs.fsx $ dotnet build GirCore.Libs.slnf If you want to clean the Libs folder of all generated files run:\n$ dotnet fsi CleanLibs.fsx Native Libraries # The project includes a C library ( GirTest ) which is used for testing the generator.\nThis requires some additional dependencies:\nC compiler meson gobject-introspection (for Ubuntu, the libgirepository1.0-dev package is required) To compile the GirTest native library, run:\n$ dotnet fsi GenerateGirTestLib.fsx Then, to include the GirTest library when generating the bindings, run:\n$ dotnet fsi GenerateLibs.fsx GirTest-0.1.gir To compile all the generated bindings, including GirTest, run:\n$ dotnet build The GirCore.sln solution contains all libraries, including GirTest. The GirCore.Libs.slnf solution filter excludes the GirTest library\u0026rsquo;s bindings and its unit tests, which can be useful if you have not built the native library.\n"}),e.add({id:2,href:"/docs/contributing.html",title:"Contributing",section:"Docs",content:` Contributing # Contributing to gir.core is very easy. If there is something wrong or missing just open an issue to get in contact or join #gircore on matrix .
If a pull request contributes new code, please be aware of the project\u0026rsquo;s license . For easy adoption of the code please adhere to the following coding guidelines.
Coding Guidelines # The following guidelines aim to provide a framework to write code in a consistent style. If the following guidelines are incomplete the official C# coding conventions and framework design guidelines apply.
Comments # Begin a comment with an uppercase letter. End a comment with a period. Insert a space before starting the comment text. Implicitly Typed Local Variables # Use var for variables if the type of the right hand side expression is obvious or not important. New Operator # Use object initializers to create objects. Members # Members include: Properties, constructors, methods, fields, events.
Call static members by using the class name: MyClass.MyMember. Fields are only allowed to be private. If needed create a property. Naming # Don\u0026rsquo;t use Hungarian notation. Don\u0026rsquo;t use abbreviations as part of identifier names. Use PascalCase for all public / protected members. Use PascalCase for all types. Use camelCase for all parameter names. Use _camelCase for all private instance fields. Structure of *.cs files # Partial classes are allowed do split the content of a class into well named files with the following notation: Class1.Part1.cs
Implementations which are external to the concrete class must be either in a separate #region or a separate partial class (e.g. interface implementations).
Inside a source file the structure is like:
Private fields (enclosed in a region tag #region Fields) Properties (enclosed in a region tag #region Properties) Constructors (enclosed in a region tag #region Constructors) Methods (enclosed in a region tag #region Methods) Access modifiers # All access modifiers should explicitly stated in the code.
`}),e.add({id:3,href:"/docs/libraries.html",title:"Libraries",section:"Docs",content:` Libraries # Currently there are multiple libraries available to get started with C# development for Linux: Gtk , WebkitGTK , libshumate libadwaita , GIO , gstreamer .
GTK # Gtk is the toolkit which is used to display windows and widgets on the screen. The widgets can be added directly in code or described through an xml file.
Supported widgets are for example: Windows, dialogs, labels, images, spinner, progressbars, several buttons and switches, textboxes, tables, lists, menus, toolbars, popovers, and much more. It powers several linux desktops like Gnome and Xfce and applications like Gimp .
Visit the GTK samples to get an overview.
libadwaita # libadwaita extends GTK with new widgets to comply to the GNOME human interface guidelines. Additionally it supports mobile devices meaning full blown applications automatically adopt their UI to different view modes, if the available space changes.
Visit the libadwaita samples to get an overview.
GIO # GIO is a library to allow easy access to input / output operations. Currently there is initial support for DBus operations. DBus is a standardized IPC-Framework which all major linux desktops use for interprocess communication.
Visit the GIO samples to get an overview.
GStreamer # GStreamer is a multimedia library to play back various media format via a flexible pipelining system. (Homepage of the free movie: https://mango.blender.org/ )
Visit the GStreamer samples to get an overview.
WebKitGTK # WebKitGTK is a browser component for GTK and can be used to embed the webkit webengine into an application as a widget. There is support for the web inspector and several settings to tweak the webview to your needs. WebKitGTK only supports Linux.
The bindings make it easy to:
Embed javascript into a webpage Call a javascript function Callback from the webpage into the C# code. Visit the WebKit samples to get an overview.
libshumate (planned) # libshumate is map component for GTK and can be used to embed maps into an application widget. By default it uses openstreetmap.
`}),e.add({id:4,href:"/docs/use.html",title:"Use",section:"Docs",content:` Use # To use the bindings create a C# project and just add the corresponding nuget packages .
There are a lot of sample projects available which should get you started.
As long as there is no API documentation available you can refer to the original documentation .
The gir.core project is not providing the actual C libraries but only the C# bindings. Please ensure that the corresponding packages are installed on your system otherwise the binding will not find a target to bind to during runtime.
In case the packages are not installed on your system please refer to the documentation of your systems package manager.
Running on Linux # In most distributions the needed packages should already be installed. In case something is missing use the package manager of your distribution to install the missing dependencies.
Running on MacOS # Use the Homebrew package database to find and install any needed packages.
Running on Windows # The easiest way to get started on Windows is by installing the packages through msys2. The MSYS2 Package Database can be searched for matching packages.
Download msys2 from the official website . Run pacman -Syu to update the package database. Run pacman -S mingw-w64-x86_64-XXX to install a package named XXX. Add the directory C:/msys64/mingw64/bin to the front of the PATH. `})})()